---
title: >
  Switching to a WebAssembly Runtime
pubDate: 2025-08-25
intro: Going forward TrailBase will rely on a WebAssembly rather than a V8 JavaScript runtime.
tags: ["WASM"]
author: sebastian
image: ./_wasm_logo.svg
---

TrailBase has been embedding a V8 runtime for the last 10 months allowing users
to implement custom HTTP and job handlers.
In this time we've experienced several issues and therefore are excited to
announce that TrailBase is moving to a WebAssembly (WASM) runtime.

The plan is for releases v0.17 and v0.18 to be transitional, i.e. supporting
both runtimes.
In v0.17 we'll first make the WASM runtime available, collect early feedback,
address any issues and stabilize the WASM guest abstractions for JS/TS and
Rust.
The subsequent v0.18 release will then mark the point when users will need to
migrate to the WASM runtime for the V8 runtime to be retired in subsequent
releases. We'll ensure that the necessary code changes will be relatively
small.

In the following article we're going to explain the rational, the opportunities
and what to watch out for.

## Rational

The V8 JavaScript runtime is a amazing piece of engineering.
However, it was never designed as a backend-first solution. It's primary target
is browsers.
It was then up to third-party vendors like Node.js and Deno to extend V8,
with a rich ecosystem to access the filessytem, sockets, etc.
These integrations are extensive and themselves have sprawling dependencies,
they're primarily developed to serve their respective CLIs rather than be
embedded elsewhere.
Just to give a sense of the size, 2/3rds of TrailBase's executable are V8 and
deno, even though we're linking only a subset of a Node.js compatible
environment.
While certainly well written, this is a bug chunk of unsafe code receiving
particular scrutiny.
Thus running even somewhat stale versions will greatly elevate risk.

Ultimately, it became a game of whack-a-mole, while not even providing a a
fully Node.js compatible environment, thus serving nobody very well.
Turns out deno links its own stale version of SQLite. Also deno doesn't build
with MUSL preventing us from building truly static binaries[^1].

The [wasmtime](https://github.com/bytecodealliance/wasmtime) WebAssembly
runtime, on the other hand is a lot simpler, safer, yet high-performant and
supports WASI[^2], which greatly eases embedding and allows us ot support guest
runtimes in multiple languages.

## Opportunities

* No accidental state sharing!
* Many more languages can be supported: C#, Python, Go, Dart, Ruby, C/C++, ...
* Safe Rust code. Consistent TLS.
* We would like this to become the de-facto path to extend TrailBase (as opposed
  to using it as a framework), while providing a lot of flexibility in terms of
  languages, ...
* This may also open up the path to using a more mainstream copy-left license.
* Better sandboxing for I/O.
* Support custom efficient SQLite extensions w/o accidental state sharing.

## Regressions

V8 is highly optimized both for loading and executing JS.
From a JS-centric perspective this may feel like a step backwards.
However, TB's integration was never a complete Node or Deno compatible runtime,
thus power-users were likely already inclined to run their preferred runtime -
Node, Deno, Bun - as a side-car.

In practice, JS is probably the least-efficient compile-to-WASM language due to
it's inherently dynamic nature (`eval()`).
While this may change, currently all ES6 compliant compilers bundle a JS
interpreter (SpiderMonkey or QuickJS). Since the interpreter's input is static,
some optimizations can be applied, i.e.
[Futamura projection using weval](https://github.com/bytecodealliance/weval).

For folks migrating, this means:

* A separate build step is needed to translate JS/TS to WASM, as opposed to
  lazily loading and just-in-time compiling a script.
* The resulting bundle, including the interpreter, tends to be large resulting
  in non-trivial initial load time in the order of seconds.
* Execution for JS is slower. Using weval, JS executing is roughly 10x slower
  than V8 but still 2x faster than non-JIT'ed runtimes like Goja while
  supporting modern ECMA standards.
  However, we can support multiple WASM components in different languages with
  many languages outperforming V8. For example, Rust-WASM components tend ot be
  X times faster than JS with V8, while requiring a significantly lower memory
  footprint and providing strict isolation between requests.

## Migration

The biggest difference you'll experience right away is the need for a build-step.
We therefore recommend to just copy the template in `examples/wasm-guest-ts`, which
supports both JavaScript and TypeScript and uses vite for building. To build
the wasm file you can simply run `pnpm install && pnpm build`.

The APIs also had to change. Previously we were relying on global state to register
handlers. However, global state is no longer shared, to avoid initialization on
every request and allow for symmetry with other guest languages that don't
support eager global initialization, we're now relying on module exports for
registering custom HTTP and Job handlers.

For state sharing between requests you'll need should rely on SQLite or
KVStore. Note that even with long-lived V8 isolates that was already the case,
since state was only shared coincidentally within the same isolate, i.e.
subsequent requests may or may not be able to see that state.

## Next-Steps

Once the new runtime integration has seen some mileage and any unexpected
surprises are worked out, we'd like to remove the V8 integration as soon as
possible. This will provide immediate benefits in terms of portability,
security, build-times and binary sizes.

From that point on we plan to invest heavily into making the integration
best-in-class. Something we were hesitant to do with the previous integration
due to all of its rough edges and unstable APIs. We'd like to introduce support
for more guest languages, making TrailBase easier to extend for a wider range
of developers developers and use-cases. If you think there's any language that
would be particularly valuable, e.g. due to its ecosystem, let us know.

When it becomes available, we'd also like to transparently upgrade the WASM
runtime to WASIp3, which will be the next standard making asynchronous
interactions between host and guest more of a first-class citizen.

---

[^1]:
    GLIBC static binaries aren't really static.

[^2]:
    As system to express cross-component interfaces for WASM in a
    language-agnostic manner. It's like gRPC but FFIi, i.e. no I/O
    thus allowing both asynchronous and synchronous interactions.
